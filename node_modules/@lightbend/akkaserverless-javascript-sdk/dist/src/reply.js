"use strict";
/*
 * Copyright 2021 Lightbend Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.noReply = exports.failure = exports.forward = exports.message = exports.Reply = void 0;
/**
 * @memberOf module:akkaserverless.replies
 */
class Effect {
    /**
     * @param {protobuf.Method} method The entity service method to invoke.
     * @param {object} message The message to send to that service.
     * @param {module:akkaserverless.Metadata} [metadata] Metadata to send with the effect.
     * @param {boolean} [synchronous] Whether the effect should be execute synchronously or not, default is false
     */
    constructor(method, message, synchronous = false, metadata) {
        this.method = method;
        this.message = message;
        this.synchronous = synchronous;
        this.metadata = metadata;
    }
}
/**
 * A return type to allow returning forwards or failures, and attaching effects to messages.
 *
 * @memberOf module:akkaserverless.replies
 */
class Reply {
    constructor(method = undefined, message = undefined, metadata = undefined, forward = undefined, failure = undefined, effects = []) {
        this.method = method;
        this.message = message;
        this.metadata = metadata;
        this.forward = forward;
        this.failure = failure;
        this.effects = effects;
    }
    getMethod() {
        return this.method;
    }
    setMethod(method) {
        this.method = method;
        return this;
    }
    getMessage() {
        return this.message;
    }
    setMessage(message) {
        this.message = message;
        return this;
    }
    getMetadata() {
        return this.metadata;
    }
    setMetadata(metadata) {
        this.metadata = metadata;
        return this;
    }
    getForward() {
        return this.forward;
    }
    setForward(forward) {
        this.forward = forward;
        return this;
    }
    getFailure() {
        return this.failure;
    }
    setFailure(failure) {
        this.failure = failure;
        return this;
    }
    getEffects() {
        return this.effects;
    }
    /**
     * Attach the given effect(s) to this reply
     *
     * @param {protobuf.Method} method The entity service method to invoke.
     * @param {object} message The message to send to that service.
     * @param {module:akkaserverless.Metadata} [metadata] Metadata to send with the effect.
     * @param {boolean} [synchronous] Whether the effect should be execute synchronously or not, default is false.
     * @return {module:akkaserverless.replies.Reply} This reply after adding the effect.
     */
    addEffect(method, message, synchronous, metadata) {
        this.addEffects([new Effect(method, message, synchronous, metadata)]);
        return this;
    }
    /**
     * Attach the given effect(s) to this reply
     *
     * @param {Effect[]} effects One or more service calls to execute as side effects
     * @return {module:akkaserverless.replies.Reply} This reply after adding the effects.
     */
    addEffects(effects) {
        if (this.effects)
            this.effects.push(...effects);
        else
            this.effects = effects;
        return this;
    }
    /**
     * Whether this reply is empty: does not have a message, forward, or failure.
     *
     * @return {boolean} Whether the reply is empty.
     */
    isEmpty() {
        return !this.message && !this.forward && !this.failure;
    }
}
exports.Reply = Reply;
/**
 * Create a message reply.
 *
 * @param {object} message the message to reply with
 * @param {module:akkaserverless.Metadata} [metadata] Optional metadata to pass with the reply
 * @return {module:akkaserverless.replies.Reply} A message reply
 */
function message(message, metadata) {
    const reply = new Reply().setMessage(message).setMetadata(metadata);
    return reply;
}
exports.message = message;
/**
 * @param {protobuf.Method} method The service call representing the forward.
 * @param {object} message The message to forward
 * @param {module:akkaserverless.Metadata} [metadata] Optional metadata to pass with the forwarded message
 * @return {module:akkaserverless.replies.Reply} A forward reply.
 */
function forward(method, message, metadata) {
    const forward = new Reply()
        .setMethod(method)
        .setMessage(message)
        .setMetadata(metadata);
    const reply = new Reply().setForward(forward);
    return reply;
}
exports.forward = forward;
/**
 * @param {String} description A description of the failure
 * @return {module:akkaserverless.replies.Reply} A failure reply.
 */
function failure(description) {
    const reply = new Reply().setFailure(description);
    return reply;
}
exports.failure = failure;
/**
 * Create a reply that contains neither a message nor a forward nor a failure.
 *
 * This may be useful for emitting effects without sending a message.
 *
 * @return {module:akkaserverless.replies.Reply} An empty reply
 */
function noReply() {
    return new Reply();
}
exports.noReply = noReply;
//# sourceMappingURL=reply.js.map